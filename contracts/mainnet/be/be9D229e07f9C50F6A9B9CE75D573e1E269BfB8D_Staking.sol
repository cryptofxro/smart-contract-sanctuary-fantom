/**
 *Submitted for verification at FtmScan.com on 2023-07-12
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Staking
*/
/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
	/**
	 * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
	 * by `operator` from `from`, this function is called.
	 *
	 * It must return its Solidity selector to confirm the token transfer.
	 * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
	 *
	 * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
	 */
	function onERC721Received(
		address operator,
		address from,
		uint256 tokenId,
		bytes calldata data
	) external returns (bytes4);
}

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface ERC721{
	function safeTransferFrom(address from, address to, uint256 tokenId) external;
}

contract Staking {

	address owner;
	struct record1 { address staker; uint256 stakeTime; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(uint256 => record1) public informationAboutStakeScheme1;
	mapping(uint256 => uint256) public tokenStore1;
	uint256 public numberOfTokensCurrentlyStaked1 = uint256(0);
	uint256 public dailyInterestRate1 = uint256(7000);
	uint256 public totalWithdrawals1 = uint256(0);
	uint256 public unstakeClaim1CoinPrice0 = uint256(20000000000000000000);
	uint256 public unstakeClaim1CoinPrice0SourceAmtInBank = uint256(0);
	struct record2 { address staker; uint256 stakeTime; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(uint256 => record2) public informationAboutStakeScheme2;
	mapping(uint256 => uint256) public tokenStore2;
	uint256 public numberOfTokensCurrentlyStaked2 = uint256(0);
	uint256 public totalWithdrawals2 = uint256(0);
	uint256 public stakeClaim2CoinPrice0 = uint256(10000000000000000000);
	uint256 public stakeClaim2CoinPrice0SourceAmtInBank = uint256(0);
	uint256 public stakeClaim2CoinPrice1 = uint256(70000000000000000000);
	uint256 public stakeClaim2CoinPrice1SourceAmtInBank = uint256(0);
	uint256 public unstakeClaim2CoinPrice0 = uint256(33000000000000000000);
	uint256 public unstakeClaim2CoinPrice0SourceAmtInBank = uint256(0);
	event Staked (uint256 indexed tokenId);
	event Unstaked (uint256 indexed tokenId);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}	

	function onERC721Received( address, address, uint256, bytes calldata ) public pure returns (bytes4) {
		return this.onERC721Received.selector;
	}

/**
 * Function stake1
 * Daily Interest Rate : Variable dailyInterestRate1
 * Address Map : informationAboutStakeScheme1
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * updates informationAboutStakeScheme1 (Element _tokenId) as Struct comprising (the address that called this function), current time, current time, 0, 0
 * calls ERC721(Address 0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)'s at safeTransferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _tokenId
 * emits event Staked with inputs _tokenId
 * updates tokenStore1 (Element numberOfTokensCurrentlyStaked1) as _tokenId
 * updates numberOfTokensCurrentlyStaked1 as (numberOfTokensCurrentlyStaked1) + (1)
*/
	function stake1(uint256 _tokenId) public {
		informationAboutStakeScheme1[_tokenId]  = record1 (msg.sender, block.timestamp, block.timestamp, uint256(0), uint256(0));
		ERC721(address(0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)).safeTransferFrom(msg.sender, address(this), _tokenId);
		emit Staked(_tokenId);
		tokenStore1[numberOfTokensCurrentlyStaked1]  = _tokenId;
		numberOfTokensCurrentlyStaked1  = (numberOfTokensCurrentlyStaked1 + uint256(1));
	}

/**
 * Function unstake1
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element _tokenId
 * creates an internal variable interestToRemove with initial value (thisRecord with element accumulatedInterestToUpdateTime) + ((((current time) - (thisRecord with element lastUpdateTime)) * (dailyInterestRate1) * (1000000000000)) / (864))
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to interestToRemove
 * if interestToRemove is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as interestToRemove)
 * updates totalWithdrawals1 as (totalWithdrawals1) + (interestToRemove)
 * checks that (thisRecord with element staker) is equals to (the address that called this function)
 * deletes item _tokenId from mapping informationAboutStakeScheme1
 * calls ERC721(Address 0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)'s at safeTransferFrom function  with variable sender as (the address of this contract), variable recipient as (the address that called this function), variable amount as _tokenId
 * emits event Unstaked with inputs _tokenId
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (if (tokenStore1 with element Loop Variable i0) is equals to _tokenId then (updates tokenStore1 (Element Loop Variable i0) as tokenStore1 with element (numberOfTokensCurrentlyStaked1) - (1); then updates numberOfTokensCurrentlyStaked1 as (numberOfTokensCurrentlyStaked1) - (1); and then terminates the for-next loop))
 * calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as unstakeClaim1CoinPrice0
 * updates unstakeClaim1CoinPrice0SourceAmtInBank as (unstakeClaim1CoinPrice0SourceAmtInBank) + (unstakeClaim1CoinPrice0)
*/
	function unstake1(uint256 _tokenId) public {
		record1 memory thisRecord = informationAboutStakeScheme1[_tokenId];
		uint256 interestToRemove = (thisRecord.accumulatedInterestToUpdateTime + (((block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate1 * uint256(1000000000000)) / uint256(864)));
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= interestToRemove), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((interestToRemove > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, interestToRemove);
		}
		totalWithdrawals1  = (totalWithdrawals1 + interestToRemove);
		require((thisRecord.staker == msg.sender), "You do not own this token");
		delete informationAboutStakeScheme1[_tokenId];
		ERC721(address(0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)).safeTransferFrom(address(this), msg.sender, _tokenId);
		emit Unstaked(_tokenId);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked1; i0++){
			if ((tokenStore1[i0] == _tokenId)){
				tokenStore1[i0]  = tokenStore1[(numberOfTokensCurrentlyStaked1 - uint256(1))];
				numberOfTokensCurrentlyStaked1  = (numberOfTokensCurrentlyStaked1 - uint256(1));
				break;
			}
		}
		ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transferFrom(msg.sender, address(this), unstakeClaim1CoinPrice0);
		unstakeClaim1CoinPrice0SourceAmtInBank  = (unstakeClaim1CoinPrice0SourceAmtInBank + unstakeClaim1CoinPrice0);
	}

/**
 * Function multipleStake1
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls stake1 with variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleStake1(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			stake1(tokenIds[i0]);
		}
	}

/**
 * Function multipleUnstake1
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls unstake1 with variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleUnstake1(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			unstake1(tokenIds[i0]);
		}
	}

/**
 * Function unstakeAllThatIOwn1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore1 with element (Loop Variable i0) - (1); and then if (informationAboutStakeScheme1 with element _tokenID with element staker) is equals to (the address that called this function) then (calls unstake1 with variable _tokenId as _tokenID))
*/
	function unstakeAllThatIOwn1() public {
		for (uint i0 = numberOfTokensCurrentlyStaked1; i0 > 0; i0--){
			uint256 _tokenID = tokenStore1[(i0 - uint256(1))];
			if ((informationAboutStakeScheme1[_tokenID].staker == msg.sender)){
				unstake1(_tokenID);
			}
		}
	}

/**
 * Function multipleWithdrawInterest1
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls withdrawInterestWithoutUnstaking1 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _tokenId as (tokenIds with element Loop Variable i0)), variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleWithdrawInterest1(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			withdrawInterestWithoutUnstaking1(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(tokenIds[i0]), tokenIds[i0]);
		}
	}

/**
 * Function withdrawAllInterestWithoutUnstaking1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore1 with element Loop Variable i0; and then if (informationAboutStakeScheme1 with element _tokenID with element staker) is equals to (the address that called this function) then (calls withdrawInterestWithoutUnstaking1 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _tokenId as _tokenID), variable _tokenId as _tokenID))
*/
	function withdrawAllInterestWithoutUnstaking1() public {
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked1; i0++){
			uint256 _tokenID = tokenStore1[i0];
			if ((informationAboutStakeScheme1[_tokenID].staker == msg.sender)){
				withdrawInterestWithoutUnstaking1(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(_tokenID), _tokenID);
			}
		}
	}

/**
 * Function updateRecordsWithLatestInterestRates1
 * The function takes in 0 variables. It can only be called by other functions in this contract. It does the following :
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element tokenStore1 with element Loop Variable i0; and then updates informationAboutStakeScheme1 (Element tokenStore1 with element Loop Variable i0) as Struct comprising (thisRecord with element staker), (thisRecord with element stakeTime), current time, ((thisRecord with element lastUpdateTime) + ((((current time) - (thisRecord with element lastUpdateTime)) * (dailyInterestRate1) * (1000000000000)) / (864))), (thisRecord with element amtWithdrawn))
*/
	function updateRecordsWithLatestInterestRates1() internal {
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked1; i0++){
			record1 memory thisRecord = informationAboutStakeScheme1[tokenStore1[i0]];
			informationAboutStakeScheme1[tokenStore1[i0]]  = record1 (thisRecord.staker, thisRecord.stakeTime, block.timestamp, (thisRecord.lastUpdateTime + (((block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate1 * uint256(1000000000000)) / uint256(864))), thisRecord.amtWithdrawn);
		}
	}

/**
 * Function numberOfStakedTokenIDsOfAnAddress1
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable _counter with initial value 0
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore1 with element Loop Variable i0; and then if (informationAboutStakeScheme1 with element _tokenID with element staker) is equals to _address then (updates _counter as (_counter) + (1)))
 * returns _counter as output
*/
	function numberOfStakedTokenIDsOfAnAddress1(address _address) public view returns (uint256) {
		uint256 _counter = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked1; i0++){
			uint256 _tokenID = tokenStore1[i0];
			if ((informationAboutStakeScheme1[_tokenID].staker == _address)){
				_counter  = (_counter + uint256(1));
			}
		}
		return _counter;
	}

/**
 * Function stakedTokenIDsOfAnAddress1
 * The function takes in 1 variable, (an address) _address. It can only be called by other functions in this contract. It does the following :
 * creates an internal variable tokenIDs
 * creates an internal variable _counter with initial value 0
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore1 with element Loop Variable i0; and then if (informationAboutStakeScheme1 with element _tokenID with element staker) is equals to _address then (updates tokenIDs (Element _counter) as _tokenID; and then updates _counter as (_counter) + (1)))
 * returns tokenIDs as output
*/
	function stakedTokenIDsOfAnAddress1(address _address) internal view returns (uint256[] memory) {
		uint256[] memory tokenIDs;
		uint256 _counter = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked1; i0++){
			uint256 _tokenID = tokenStore1[i0];
			if ((informationAboutStakeScheme1[_tokenID].staker == _address)){
				tokenIDs[_counter]  = _tokenID;
				_counter  = (_counter + uint256(1));
			}
		}
		return tokenIDs;
	}

/**
 * Function whichStakedTokenIDsOfAnAddress1
 * The function takes in 2 variables, (an address) _address, and (zero or a positive integer) _counterIn. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable _counter with initial value 0
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore1 with element Loop Variable i0; and then if (informationAboutStakeScheme1 with element _tokenID with element staker) is equals to _address then (if _counterIn is equals to _counter then (returns _tokenID as output); and then updates _counter as (_counter) + (1)))
 * returns 9999999 as output
*/
	function whichStakedTokenIDsOfAnAddress1(address _address, uint256 _counterIn) public view returns (uint256) {
		uint256 _counter = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked1; i0++){
			uint256 _tokenID = tokenStore1[i0];
			if ((informationAboutStakeScheme1[_tokenID].staker == _address)){
				if ((_counterIn == _counter)){
					return _tokenID;
				}
				_counter  = (_counter + uint256(1));
			}
		}
		return uint256(9999999);
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element _tokenId
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + ((((current time) - (thisRecord with element lastUpdateTime)) * (dailyInterestRate1) * (1000000000000)) / (864)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(uint256 _tokenId) public view returns (uint256) {
		record1 memory thisRecord = informationAboutStakeScheme1[_tokenId];
		return (thisRecord.accumulatedInterestToUpdateTime + (((block.timestamp - thisRecord.lastUpdateTime) * dailyInterestRate1 * uint256(1000000000000)) / uint256(864)));
	}

/**
 * Function withdrawInterestWithoutUnstaking1
 * The function takes in 2 variables, (zero or a positive integer) _withdrawalAmt, and (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable totalInterestEarnedTillNow with initial value interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _tokenId as _tokenId
 * checks that _withdrawalAmt is less than or equals to totalInterestEarnedTillNow
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element _tokenId
 * checks that (thisRecord with element staker) is equals to (the address that called this function)
 * updates informationAboutStakeScheme1 (Element _tokenId) as Struct comprising (thisRecord with element staker), (thisRecord with element stakeTime), current time, ((totalInterestEarnedTillNow) - (_withdrawalAmt)), ((thisRecord with element amtWithdrawn) + (_withdrawalAmt))
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _withdrawalAmt
 * if _withdrawalAmt is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _withdrawalAmt)
 * updates totalWithdrawals1 as (totalWithdrawals1) + (_withdrawalAmt)
*/
	function withdrawInterestWithoutUnstaking1(uint256 _withdrawalAmt, uint256 _tokenId) public {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(_tokenId);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record1 memory thisRecord = informationAboutStakeScheme1[_tokenId];
		require((thisRecord.staker == msg.sender), "You do not own this token");
		informationAboutStakeScheme1[_tokenId]  = record1 (thisRecord.staker, thisRecord.stakeTime, block.timestamp, (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= _withdrawalAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_withdrawalAmt > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, _withdrawalAmt);
		}
		totalWithdrawals1  = (totalWithdrawals1 + _withdrawalAmt);
	}

/**
 * Function withdrawAllInterestFromATokenWithoutUnstaking1
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can only be called by functions outside of this contract. It does the following :
 * calls withdrawInterestWithoutUnstaking1 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _tokenId as _tokenId), variable _tokenId as _tokenId
*/
	function withdrawAllInterestFromATokenWithoutUnstaking1(uint256 _tokenId) external {
		withdrawInterestWithoutUnstaking1(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(_tokenId), _tokenId);
	}

/**
 * Function totalAccumulatedInterest1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfTokensCurrentlyStaked1 times with loop variable i0 :  (updates total as (total) + (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _tokenId as (Loop Variable i0)))
 * returns total as output
*/
	function totalAccumulatedInterest1() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked1; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(i0));
		}
		return total;
	}

/**
 * Function modifyDailyInterestRate1
 * Notes for _dailyInterestRate : 10000 is one coin
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * calls updateRecordsWithLatestInterestRates1
 * updates dailyInterestRate1 as _dailyInterestRate
*/
	function modifyDailyInterestRate1(uint256 _dailyInterestRate) public onlyOwner {
		updateRecordsWithLatestInterestRates1();
		dailyInterestRate1  = _dailyInterestRate;
	}

/**
 * Function stake2
 * Daily Interest Rate : 1.5
 * Address Map : informationAboutStakeScheme2
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * calls ERC20(Address 0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as stakeClaim2CoinPrice0
 * updates stakeClaim2CoinPrice0SourceAmtInBank as (stakeClaim2CoinPrice0SourceAmtInBank) + (stakeClaim2CoinPrice0)
 * calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as stakeClaim2CoinPrice1
 * updates stakeClaim2CoinPrice1SourceAmtInBank as (stakeClaim2CoinPrice1SourceAmtInBank) + (stakeClaim2CoinPrice1)
 * updates informationAboutStakeScheme2 (Element _tokenId) as Struct comprising (the address that called this function), current time, current time, 0, 0
 * calls ERC721(Address 0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)'s at safeTransferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _tokenId
 * emits event Staked with inputs _tokenId
 * updates tokenStore2 (Element numberOfTokensCurrentlyStaked2) as _tokenId
 * updates numberOfTokensCurrentlyStaked2 as (numberOfTokensCurrentlyStaked2) + (1)
*/
	function stake2(uint256 _tokenId) public {
		ERC20(address(0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e)).transferFrom(msg.sender, address(this), stakeClaim2CoinPrice0);
		stakeClaim2CoinPrice0SourceAmtInBank  = (stakeClaim2CoinPrice0SourceAmtInBank + stakeClaim2CoinPrice0);
		ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transferFrom(msg.sender, address(this), stakeClaim2CoinPrice1);
		stakeClaim2CoinPrice1SourceAmtInBank  = (stakeClaim2CoinPrice1SourceAmtInBank + stakeClaim2CoinPrice1);
		informationAboutStakeScheme2[_tokenId]  = record2 (msg.sender, block.timestamp, block.timestamp, uint256(0), uint256(0));
		ERC721(address(0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)).safeTransferFrom(msg.sender, address(this), _tokenId);
		emit Staked(_tokenId);
		tokenStore2[numberOfTokensCurrentlyStaked2]  = _tokenId;
		numberOfTokensCurrentlyStaked2  = (numberOfTokensCurrentlyStaked2 + uint256(1));
	}

/**
 * Function unstake2
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element _tokenId
 * creates an internal variable interestToRemove with initial value (thisRecord with element accumulatedInterestToUpdateTime) + ((((current time) - (thisRecord with element lastUpdateTime)) * (15000) * (1000000000000)) / (864))
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to interestToRemove
 * if interestToRemove is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as interestToRemove)
 * updates totalWithdrawals2 as (totalWithdrawals2) + (interestToRemove)
 * checks that (thisRecord with element staker) is equals to (the address that called this function)
 * deletes item _tokenId from mapping informationAboutStakeScheme2
 * calls ERC721(Address 0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)'s at safeTransferFrom function  with variable sender as (the address of this contract), variable recipient as (the address that called this function), variable amount as _tokenId
 * emits event Unstaked with inputs _tokenId
 * repeat numberOfTokensCurrentlyStaked2 times with loop variable i0 :  (if (tokenStore2 with element Loop Variable i0) is equals to _tokenId then (updates tokenStore2 (Element Loop Variable i0) as tokenStore2 with element (numberOfTokensCurrentlyStaked2) - (1); then updates numberOfTokensCurrentlyStaked2 as (numberOfTokensCurrentlyStaked2) - (1); and then terminates the for-next loop))
 * calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as unstakeClaim2CoinPrice0
 * updates unstakeClaim2CoinPrice0SourceAmtInBank as (unstakeClaim2CoinPrice0SourceAmtInBank) + (unstakeClaim2CoinPrice0)
*/
	function unstake2(uint256 _tokenId) public {
		record2 memory thisRecord = informationAboutStakeScheme2[_tokenId];
		uint256 interestToRemove = (thisRecord.accumulatedInterestToUpdateTime + (((block.timestamp - thisRecord.lastUpdateTime) * uint256(15000) * uint256(1000000000000)) / uint256(864)));
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= interestToRemove), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((interestToRemove > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, interestToRemove);
		}
		totalWithdrawals2  = (totalWithdrawals2 + interestToRemove);
		require((thisRecord.staker == msg.sender), "You do not own this token");
		delete informationAboutStakeScheme2[_tokenId];
		ERC721(address(0x797a90D43F9095D47be0A2aA823AF04a5BeDB268)).safeTransferFrom(address(this), msg.sender, _tokenId);
		emit Unstaked(_tokenId);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked2; i0++){
			if ((tokenStore2[i0] == _tokenId)){
				tokenStore2[i0]  = tokenStore2[(numberOfTokensCurrentlyStaked2 - uint256(1))];
				numberOfTokensCurrentlyStaked2  = (numberOfTokensCurrentlyStaked2 - uint256(1));
				break;
			}
		}
		ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transferFrom(msg.sender, address(this), unstakeClaim2CoinPrice0);
		unstakeClaim2CoinPrice0SourceAmtInBank  = (unstakeClaim2CoinPrice0SourceAmtInBank + unstakeClaim2CoinPrice0);
	}

/**
 * Function multipleStake2
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls stake2 with variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleStake2(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			stake2(tokenIds[i0]);
		}
	}

/**
 * Function multipleUnstake2
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls unstake2 with variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleUnstake2(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			unstake2(tokenIds[i0]);
		}
	}

/**
 * Function unstakeAllThatIOwn2
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat numberOfTokensCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore2 with element (Loop Variable i0) - (1); and then if (informationAboutStakeScheme2 with element _tokenID with element staker) is equals to (the address that called this function) then (calls unstake2 with variable _tokenId as _tokenID))
*/
	function unstakeAllThatIOwn2() public {
		for (uint i0 = numberOfTokensCurrentlyStaked2; i0 > 0; i0--){
			uint256 _tokenID = tokenStore2[(i0 - uint256(1))];
			if ((informationAboutStakeScheme2[_tokenID].staker == msg.sender)){
				unstake2(_tokenID);
			}
		}
	}

/**
 * Function multipleWithdrawInterest2
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls withdrawInterestWithoutUnstaking2 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _tokenId as (tokenIds with element Loop Variable i0)), variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleWithdrawInterest2(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			withdrawInterestWithoutUnstaking2(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(tokenIds[i0]), tokenIds[i0]);
		}
	}

/**
 * Function withdrawAllInterestWithoutUnstaking2
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat numberOfTokensCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore2 with element Loop Variable i0; and then if (informationAboutStakeScheme2 with element _tokenID with element staker) is equals to (the address that called this function) then (calls withdrawInterestWithoutUnstaking2 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _tokenId as _tokenID), variable _tokenId as _tokenID))
*/
	function withdrawAllInterestWithoutUnstaking2() public {
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked2; i0++){
			uint256 _tokenID = tokenStore2[i0];
			if ((informationAboutStakeScheme2[_tokenID].staker == msg.sender)){
				withdrawInterestWithoutUnstaking2(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(_tokenID), _tokenID);
			}
		}
	}

/**
 * Function numberOfStakedTokenIDsOfAnAddress2
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable _counter with initial value 0
 * repeat numberOfTokensCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore2 with element Loop Variable i0; and then if (informationAboutStakeScheme2 with element _tokenID with element staker) is equals to _address then (updates _counter as (_counter) + (1)))
 * returns _counter as output
*/
	function numberOfStakedTokenIDsOfAnAddress2(address _address) public view returns (uint256) {
		uint256 _counter = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked2; i0++){
			uint256 _tokenID = tokenStore2[i0];
			if ((informationAboutStakeScheme2[_tokenID].staker == _address)){
				_counter  = (_counter + uint256(1));
			}
		}
		return _counter;
	}

/**
 * Function stakedTokenIDsOfAnAddress2
 * The function takes in 1 variable, (an address) _address. It can only be called by other functions in this contract. It does the following :
 * creates an internal variable tokenIDs
 * creates an internal variable _counter with initial value 0
 * repeat numberOfTokensCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore2 with element Loop Variable i0; and then if (informationAboutStakeScheme2 with element _tokenID with element staker) is equals to _address then (updates tokenIDs (Element _counter) as _tokenID; and then updates _counter as (_counter) + (1)))
 * returns tokenIDs as output
*/
	function stakedTokenIDsOfAnAddress2(address _address) internal view returns (uint256[] memory) {
		uint256[] memory tokenIDs;
		uint256 _counter = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked2; i0++){
			uint256 _tokenID = tokenStore2[i0];
			if ((informationAboutStakeScheme2[_tokenID].staker == _address)){
				tokenIDs[_counter]  = _tokenID;
				_counter  = (_counter + uint256(1));
			}
		}
		return tokenIDs;
	}

/**
 * Function whichStakedTokenIDsOfAnAddress2
 * The function takes in 2 variables, (an address) _address, and (zero or a positive integer) _counterIn. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable _counter with initial value 0
 * repeat numberOfTokensCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable _tokenID with initial value tokenStore2 with element Loop Variable i0; and then if (informationAboutStakeScheme2 with element _tokenID with element staker) is equals to _address then (if _counterIn is equals to _counter then (returns _tokenID as output); and then updates _counter as (_counter) + (1)))
 * returns 9999999 as output
*/
	function whichStakedTokenIDsOfAnAddress2(address _address, uint256 _counterIn) public view returns (uint256) {
		uint256 _counter = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked2; i0++){
			uint256 _tokenID = tokenStore2[i0];
			if ((informationAboutStakeScheme2[_tokenID].staker == _address)){
				if ((_counterIn == _counter)){
					return _tokenID;
				}
				_counter  = (_counter + uint256(1));
			}
		}
		return uint256(9999999);
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element _tokenId
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + ((((current time) - (thisRecord with element lastUpdateTime)) * (15000) * (1000000000000)) / (864)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(uint256 _tokenId) public view returns (uint256) {
		record2 memory thisRecord = informationAboutStakeScheme2[_tokenId];
		return (thisRecord.accumulatedInterestToUpdateTime + (((block.timestamp - thisRecord.lastUpdateTime) * uint256(15000) * uint256(1000000000000)) / uint256(864)));
	}

/**
 * Function withdrawInterestWithoutUnstaking2
 * The function takes in 2 variables, (zero or a positive integer) _withdrawalAmt, and (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable totalInterestEarnedTillNow with initial value interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _tokenId as _tokenId
 * checks that _withdrawalAmt is less than or equals to totalInterestEarnedTillNow
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element _tokenId
 * checks that (thisRecord with element staker) is equals to (the address that called this function)
 * updates informationAboutStakeScheme2 (Element _tokenId) as Struct comprising (thisRecord with element staker), (thisRecord with element stakeTime), current time, ((totalInterestEarnedTillNow) - (_withdrawalAmt)), ((thisRecord with element amtWithdrawn) + (_withdrawalAmt))
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _withdrawalAmt
 * if _withdrawalAmt is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _withdrawalAmt)
 * updates totalWithdrawals2 as (totalWithdrawals2) + (_withdrawalAmt)
*/
	function withdrawInterestWithoutUnstaking2(uint256 _withdrawalAmt, uint256 _tokenId) public {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(_tokenId);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record2 memory thisRecord = informationAboutStakeScheme2[_tokenId];
		require((thisRecord.staker == msg.sender), "You do not own this token");
		informationAboutStakeScheme2[_tokenId]  = record2 (thisRecord.staker, thisRecord.stakeTime, block.timestamp, (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= _withdrawalAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_withdrawalAmt > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, _withdrawalAmt);
		}
		totalWithdrawals2  = (totalWithdrawals2 + _withdrawalAmt);
	}

/**
 * Function withdrawAllInterestFromATokenWithoutUnstaking2
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can only be called by functions outside of this contract. It does the following :
 * calls withdrawInterestWithoutUnstaking2 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _tokenId as _tokenId), variable _tokenId as _tokenId
*/
	function withdrawAllInterestFromATokenWithoutUnstaking2(uint256 _tokenId) external {
		withdrawInterestWithoutUnstaking2(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(_tokenId), _tokenId);
	}

/**
 * Function totalAccumulatedInterest2
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfTokensCurrentlyStaked2 times with loop variable i0 :  (updates total as (total) + (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _tokenId as (Loop Variable i0)))
 * returns total as output
*/
	function totalAccumulatedInterest2() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfTokensCurrentlyStaked2; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(i0));
		}
		return total;
	}

/**
 * Function withdrawToken
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((_amt) + (totalAccumulatedInterest1) + (totalAccumulatedInterest2))
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function withdrawToken(uint256 _amt) public onlyOwner {
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= (_amt + totalAccumulatedInterest1() + totalAccumulatedInterest2())), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, _amt);
		}
	}

/**
 * Function unstakeClaim1CoinPrice0SourceTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to unstakeClaim1CoinPrice0SourceAmtInBank
 * if unstakeClaim1CoinPrice0SourceAmtInBank is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as unstakeClaim1CoinPrice0SourceAmtInBank)
 * updates unstakeClaim1CoinPrice0SourceAmtInBank as 0
*/
	function unstakeClaim1CoinPrice0SourceTaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= unstakeClaim1CoinPrice0SourceAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((unstakeClaim1CoinPrice0SourceAmtInBank > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, unstakeClaim1CoinPrice0SourceAmtInBank);
		}
		unstakeClaim1CoinPrice0SourceAmtInBank  = uint256(0);
	}

/**
 * Function stakeClaim2CoinPrice0SourceTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to stakeClaim2CoinPrice0SourceAmtInBank
 * if stakeClaim2CoinPrice0SourceAmtInBank is strictly greater than 0 then (calls ERC20(Address 0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e)'s at transfer function  with variable recipient as (the address that called this function), variable amount as stakeClaim2CoinPrice0SourceAmtInBank)
 * updates stakeClaim2CoinPrice0SourceAmtInBank as 0
*/
	function stakeClaim2CoinPrice0SourceTaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e)).balanceOf(address(this)) >= stakeClaim2CoinPrice0SourceAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((stakeClaim2CoinPrice0SourceAmtInBank > uint256(0))){
			ERC20(address(0xF24Bcf4d1e507740041C9cFd2DddB29585aDCe1e)).transfer(msg.sender, stakeClaim2CoinPrice0SourceAmtInBank);
		}
		stakeClaim2CoinPrice0SourceAmtInBank  = uint256(0);
	}

/**
 * Function stakeClaim2CoinPrice1SourceTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to stakeClaim2CoinPrice1SourceAmtInBank
 * if stakeClaim2CoinPrice1SourceAmtInBank is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as stakeClaim2CoinPrice1SourceAmtInBank)
 * updates stakeClaim2CoinPrice1SourceAmtInBank as 0
*/
	function stakeClaim2CoinPrice1SourceTaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= stakeClaim2CoinPrice1SourceAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((stakeClaim2CoinPrice1SourceAmtInBank > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, stakeClaim2CoinPrice1SourceAmtInBank);
		}
		stakeClaim2CoinPrice1SourceAmtInBank  = uint256(0);
	}

/**
 * Function unstakeClaim2CoinPrice0SourceTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to unstakeClaim2CoinPrice0SourceAmtInBank
 * if unstakeClaim2CoinPrice0SourceAmtInBank is strictly greater than 0 then (calls ERC20(Address 0xf083E641BE17b44a6ea0bF8383c3a057876fD775)'s at transfer function  with variable recipient as (the address that called this function), variable amount as unstakeClaim2CoinPrice0SourceAmtInBank)
 * updates unstakeClaim2CoinPrice0SourceAmtInBank as 0
*/
	function unstakeClaim2CoinPrice0SourceTaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).balanceOf(address(this)) >= unstakeClaim2CoinPrice0SourceAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((unstakeClaim2CoinPrice0SourceAmtInBank > uint256(0))){
			ERC20(address(0xf083E641BE17b44a6ea0bF8383c3a057876fD775)).transfer(msg.sender, unstakeClaim2CoinPrice0SourceAmtInBank);
		}
		unstakeClaim2CoinPrice0SourceAmtInBank  = uint256(0);
	}
}