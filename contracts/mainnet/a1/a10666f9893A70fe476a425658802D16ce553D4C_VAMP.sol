// SPDX-License-Identifier: MIT
//   #(#.       ,,,%,,,,,,,.##,,,,,,,,,,,,/%#%,,,,,,,,,,,.%%#%,,,,,,%%#%#%##%#.,,,,/##,,,,,,*%#%#%#%#%*,,,,,,,,*#%#%##%%))#
//   ,##((      ,/#(.,,,,,*(*%#(*.,,,,,,,,/(*%#*.,,,,,,.,#.##%.,,,.(#%*,,,,.%#%.,,.*%%/.,,, .%%,,,,,.(##(,,,,,,*##*
//    .##%     ..#.,,,,,. #,,,%%/,,,,,,,,,.#.*%%/..,,,,,%.(###.,,,,.%%,,,,,/###,,,,*#%..,,,,,##,.,,..###.,,,,,.##%*    
//      (##/   #%.,,,,,.##.,,,(##/,,,,,,,..#.,.%%/(,,./#.,.%%*,,,,,.%%.,.*#%#.,,,,,*#%.,,,,,.%#*.(#%(/,.,,,,,,,*%###((((%#
//      ./%%, .%.,,,,,,.%%%%####%#(.,,,,,.##.,,.%#%.,((.,.*##*,,,,..%#(.,,,,,,,,,,,*#%.,,,,,,#%,..(%#(.,,,,,,,,,##*   
//        /#%*#.,,,,,.,#.,,,,,,,.###*,,,,,.#,,,.,####(.,,,.%##.,,,,(##.,,,,,,,,,,,.###(,,,,,/##/,,,.(##/.,,,,,,/%##   
//         ,%%.,,,,,.##.. . ..,,,*###.,,,,,%**,,,.(%,,,,,,,##/,,,,,,##*,,,,,,,,,,,,/#%,,,,,,,##/,,,,.*###*..,,,/#####(((#%(
//           @   */////////*////((//(//((((((((####((##############(#(((((####/,/#########**.,.. .######(  .##,
//              *///////////((((((##(####(##################%#%############################(*####,   ..#    ###*
//             .//*/////////(####(#####%###########################################/(##(####.(. ....*###(# #,###(.
//             .//////////*/((#/#(##########################%###########%#########......./###(.. /#  (##  ,(##       .*
//            .////////,,,,,,,,,*****/*/(####%#%#%###############%##%##########//,..,...,,,.*##((((# .###((      ..
//            ./////**.... ....... ,....,.,******//(##(########(//(*(/#(#...   ,,/..........##### ,#*/# .       .  .#.(
//           .*/////////,*.                .    ...*,,,**#####/,,,.   ##*. *@@@(@@@@@.. .../#####(* .#  /    . ######.#
//           .//////////////..,&@@@@@@#&@@&%@.       ,*(#####(/,.    /#, @@@@@@@@@@@@,.##(######/.  #####.#(########.
//           .////////(((#///,,((#&&@@@&&@@@(,,./(//*/(###%&##(/,,#####     .,&( .,...(#./,.##/##############.##,
//           .//////((#######//**,*.*.*/**///######%#(##%%&&%##/*/((##.. .,.,/((/((..#...*###################    ..
//            .*////#(##########(//*(////((#######(#######&&###/*/(((#(##( .*####(*#,(.,*(,#################       ...
//             .*///(################################(####&@%##/*((#(#########,.*. ...,..#############              ...
//             ../////(###################################%@##(///(##################/#############.*/#.             .
//               .*/////##################################&&##///((##*  ###########*###############, #,.        ..
//                .,/////(################################&&%#(/((####*...###########################,         .      .
//               . ..*///(/##############################%&&%##((#########./#########*###############,     .
//                 ...*//////(#########%########/(#((#####%%############(####################.#######                 .
//                  ...///////((###############//(#######%#################/# *############,########             ..
//                    .,//////((#(##############//(/######&@&#(########.(#/ ##..#########(######/     *, .,**///*    ..
//                     .*///////###############/**,*/#####%%#####/#( ./#  ./*//. #############/..           ./////*////
//                      ../////((##############( .   .**###(###    .  .     ,,#.(.##########*                   *,,/**.
//                       ..*//////(##(%##########(((*.  ,,,#(#           .   . .*######### .////                  *,* ,
//                        ..*///////(#####//#/(/***/,,,,  .##                  . #######***.  *//               .,. *..
//                          .,///////*,*,*,,,*,,,,,, .(#((##        .        .    . .,****,*,*////**          */,,. *//
//                           .////*,. ......,.,., ..,.(####.     ...,. [email protected]@   ....   .   ,*////////*           ,**,,.*,.
//                            .*/,..              . ...##(   .   &&.*@@@@     . .        **////////*///**  .   ,   ..
//                              .,.                   .##. #@#@*@@&,@@@@*      ...  ,//*///*,//./*./////***    *,
//                              . .    ..**//*/,.......##  &@@@ @@@ @@@@        /// ..///////////////  */*.,.**/
//                                     *//////////(**/##    @@   @  &@@...    ,/*,,//*///////***///*/// ,/   /*,
//                                    .,,/////////////#(             @ ..,   ,//*, .///*.. . ,,,*//////.    ,,
//                                   ....*////*....#/##                @@.   ////*,**/*///**,,,///,.,,,,.
//                                     ...*////,**(###.               %@@@  /////,./*/,////*////.  .,**  *
//                                        ..*/////### .             @%#/.  ./////,.***//*////*,**. ***        `       .
//                                         ...,/(####.  .          .#@/*(  //////*/////////****
//                                           .((####(  ..        %@#@#&,,,*//////////////**/..              `     `
//                                           ... ###          .  %((/%&**////,.../*,.., **,,, .              `      `
//                                     . ......####     .     [email protected]&#&/* , **//.//*,       ,**.  */.  *.
//                                   **(########### %#  #*[email protected]  &%%%/....*///*,**       . ..  .,******/.      `       `
//        .            ..       ...     . #/###########%(##@# ,&.  */*///*,,,           .****,,.    /                 .
//         ..                       ... ..  ,*#######*(.#..#.     ,//*. ,.*/.        ..*.                .,,,,,***,,,.
//                                      .  , ..####          ..   ***,,,,,         .               .**,        .
//                                .   .    . .,,./,.     .   . .**//,*, ,      .,.         .**... ,  .       ..
//                                      ..   *.  . .(.    ....*,**., */*.  ,*,          .*.
//                  .   .           .   ......      .   .  . .*/**////.,*/*//,  ..,****.
//                ...            ..  ...... .      ..,....      ..,   ...   .*//*,.  ,..        ..


/*




Vampire (VAMP) is a deflationary fair launched token designed to have big buybacks and burns by incorporating a Jackpot system.

Website: https://vampire.biz
Twitter: https://twitter.com/VampToken
Telegram: https://t.me/VampireToken
Discord: https://discord.gg/ANAqkm5xrk

Whitepaper: https://vampire.biz/whitepaper
Bloodpaper: https://vampire.biz/bloodpaper
Team: https://vampire.biz/team
Audits: https://vampire.biz/audits



====================EXECUTIVE SUMMARY===============
When someone buys $10 of VAMP they become the last buyer stored in the smart contract code.
If there are no new buyers for 10 minutes, then the last buyer wins half the FTM Jackpot stored inside the smart contract.
The other half of the FTM Jackpot is used to buyback and burn VAMP. A small portion is used to pay the team for marketing and development.
If someone makes a new purchase then they become the new last buyer and the 10 minute timer is reset.
This means there is no way to rig a buy so that the last buyer can be the winner of the Jackpot, without waiting 10 minutes.

The Jackpot has a hardlimit of $100,000.
When the Jackpot reaches $100,000 Morbin Time is released.
Morbin Time will use $70,000 to perform a massive buyback and burn.
$30,000 will be left to restart the Jackpot so that there is always a Jackpot to be won, and pay the team for marketing and development costs.

New buyers are incentivized because there is always a Jackpot to be won.

Sellers are discouraged because of the 8% sell tax, which sucks the FTM into the Jackpot.

The Jackpot and Morbin Time bring up the price floor as VAMP is bought back and burned.

VAMP is a true deflationary token, there is no yield generation or way to gain back the VAMP that has been burned.

It's the only project on FTM that literally sucks!



====================GOOD TOKENOMICS================
VAMP's total supply is 1,000,000 (1 Million) and the breakdown is the following:

4% - 40,000 VAMP - Marketing, Locked for 90 days in the VAMP Coffin Locker Contract
1% - 10,000 VAMP - Dev Team, Locked for 90 days in the VAMP Coffin Locker Contract
5% - 50,000 VAMP - CEX Liquidity, Locked for 180 days in the VAMP Coffin Locker Contract
40% - 400,000 VAMP - Liquidity Fair Launched on SpookySwap
50% - 500,000 VAMP - Burned Right Before Fair Launch



======================LOW TAXES====================
To fund the Jackpot and Morbin Time, low taxes are performed on each buy, sell, and trasfer.
2% on each Transfer.
3% on each Buy.
8% on each Sell.

Jackpot Tax Breakdown:
1% on Transfers.
2% on Buys.
5% on Sells.

Marketing Tax Breakdown:
1% on Transfers.
1% on Buys.
2% on Sells.



======================LIQUIDITY=====================
Starting Liquidity of VAMP/FTM is 400,000 VAMP paired with $5,000 of FTM
This results in a starting marketcap of $5,000 and a price of $0.0125 per VAMP
This Liquidity is locked for 180 days in the VAMP Coffin Locker Contract



======================ROADMAP=======================
July 1st - Website, Social Media, and Communities are launched.
July 8th - VAMPIRE BLOOD DRIP - NFTs are given to anyone who would like one.
July 15th - Liquidity Fair Launched
July 16th - VAMP is listed on several token trackers such as CoinGecko, CoinMarketCap, etc.
July 22nd - Contact established with SpookySwap, Tomb, Fantom Foundation, and other Fantom Eco System Projects
July 29th - Deploy any new projects and pools with any partnered projects.
August 19th - Deploy a welding business website to promote real world ventures.
September 2nd - Build a BLOOD BOOK system that allows a centralized exchange style order book, but using a decentralized smart contract.
All dates are tentative.



===============VAMPIRE BLOOD DRIP NFTS===============
10,000 Vampire NFTs were minted to be given as a Blood Drip.
These were created with PaintSwap and are able to be traded, sold, and purchased.
To get your free NFT visit discord, telegram, or twitter and request one.



=================NO VENTURE CAPITALISTS=============
VAMP does not have Venture Capitalist funding.
VAMP did not have a presale.
VAMP did not have a private sale.
Vampire's funding comes directly from the team.



==================INVESTOR PROTECTION===============
VAMP stops bot contracts from participating in the Jackpot. 
Contracts can still interact with the contract to buy, sell, and transfer normally, but they will not be counted as the Last Buyer.
This safeguards the Jackpot mechanism from rigging buys so that the Jackpot would never fire.



===================MAX WALLET SIZE==================
Each wallet can only have a maximum of 50,000 VAMP (5% of the total supply).
This helps curb Whales from buying and controlling the supply.



===================DAO PARTNERSHIP==================
VAMP seeks to become partnered with existing DAOs to further expand the Fantom Ecosystem.
VAMP does not intend to become its own DAO.



=======================AUDITS=======================
Audits are in queue and will be updated on Vampire's website and announce on social media.



===================CEX LISTINGS=====================
VAMP is reaching out to the following CEXs:
KuCoin
Gate.io
Hotbit
MEXC
BKEX
BitMart
XT.COM
CoinEx
and of course.... Binance



======================TEAM==========================
JaWohlDev - Graphic Designer and Scripting Developer for Morbin Time and Jackpot Announcements
Triss - Web Developer and Frontend Engineer
Henry Case - Smart Contract Developer
Giacomo - Marketer and Community Management
Bonham - NFT AI Developer and Meme Maker
Contact us through Discord, Telegram, Twitter, or send an email to [email protected]



==================JACKPOT EXAMPLE====================
This example uses rough estimates. 
Prices are not intended to be exact.
This is not intended to be a model of how Liquidity Pools work. 
Price impacts are removed to illustrate the use case.

Starting Scenario:
Pool: 10000 VAMP / 1000 FTM
Price: 1 VAMP = 0.1 FTM
Jackpot: 0 FTM

Buyer uses 100 FTM to buy 1000 VAMP
10% of the VAMP (100 VAMP) is taken and sold back for 10 FTM.
This FTM is moved into the Jackpot.

Pool: 9100 VAMP / 1090 FTM
Price: 1 VAMP = 0.12 FTM
Jackpot Amount: 10 FTM

Buyer uses 100 FTM to buy 1000 VAMP
This time it would take a little bit more FTM to buy 100 VAMP as the price has increased, 
but we will round it down to make the price "fit" for the example.

Pool: 8200 VAMP / 1180 FTM
Price: 1 VAMP = 0.14 FTM
Jackpot Amount: 20 FTM

Jackpot activates because the Buyer 
was the Last Buyer for 10 minutes.
Winner is awarded 50% of the FTM Jackpot = 10 FTM
30% of the FTM Jackpot is used to buyback and burn = 6 FTM
6 FTM is swapped to buy 43 VAMP for 0.14 FTM per VAMP

Ending Pool
Pool: 8157 VAMP / 1186 FTM
Price: 1 VAMP = 0.15 FTM
Jackpot: 3 FTM (Leftover to Restart)

The 43 VAMP is burned completely out of the system never to be used again.

Morbin Time uses 70% to buyback and burn, leaving 20% for the next Jackpot.

The VAMP Team takes a small portion of the Jackpot FTM 
each time the Jackpot and Morbin Time Activates.



=================PRICE PROJECTION===============
This is not financial advice nor is this chart intended to help make you financial decisions.
Talk to your financial advisor not your telegram alpha group or your mongolian basketweaving forum.
*/
//............................................................................................................................................................................     
//                  Vampire (VAMP) Price Projections        -       Price Floor Raised Each Jackpot and Morbin Time Because of the Buyback and Burn                                                                                                                                        
//                                                                                                                                                               $$
//                                                                                                                                                              //   
//                                                                                                                                                             //
//                                                                                                                                               $$           //   
//                                                                                                                                              //\\         //    
//                                                                                                                                             //  \\       //     
//                                                                                                                 Morbin Time                //    \\     //    
//                                                                                                                                           //      \\   //      
//   Price Floor 3 .........................................................................................................................//........\\_//....Price Floor Raised Each Jackpot and Morbin Time  
//                                                                                                                                         //    
//                                                                                                                                        //       
//                                                                                                                                       //           
//                                                                                                                                      //            
//                                                                                                                      $$             //               
//                                                                                                                     //\\           //                  
//                                                                                                                    //  \\         //                    
//                                                                                                                   //    \\       //                     
//                                                                                               2nd Jackpot        //      \\     //                     
//                                                                                                                 //        \\   //     
//   Price Floor 2 ...............................................................................................//..........\\_//.......Price Floor Raised Each Jackpot and Morbin Time           
//                                                                                                               //                             
//                                                                                                              //                                
//                                                                                                             //                                 
//                                                 $$$                               $$                       $$                                  
//                                                ////                             . //                       ||                                   
//                                              /,,/* /.                         / /   \\            $$       ||                                    
//                                            ,///    ./,                      /        \\           //\\    ||                                      
//                                           //        .//                //  /          \\         //  \\  //                                        
//                   First Jackpot         //          *  //        /  / /                \\       //    \\//                                         
//                                        //             / ,/      / //                    \\     //                                              
//   Price Flooor 1 .....................//................/.././///........................\\___//..............Price Floor Raised Each Jackpot and Morbin Time
//                                     ///                                                                                     
//                                   /,/                                                                                  
//                                  /,/                                                                                            
//                                 /,/                                                                                             
//                                /,/                                                                                                               
//                               /,/                                                                                  
//                             ///                                                                                                                   
//                            /,/                                                                                                                          
//                        //////                                                                                                                                   
//                    ////                                                                                                                                      
//             //////                                                                                                                                      
//    //////////                                                                                                                                                                                        
//............................................................................................................................................................................    
//           LAUNCH                Week 1                Week 2                 Week 3               Month 1                          Month 2



pragma solidity ^0.8.15;



// Imports From OpenZeppelin - Updated Solidity Version
// Interfaces
import "../interfaces/IERC20.sol";
import "../interfaces/IERC20Metadata.sol";
// SpookySwap Interfaces
import "../interfaces/IUniswapV2Router02.sol";
import "../interfaces/IUniswapV2Factory.sol";
// Libraries
import "../libraries/SafeMath.sol";
// Utilities
import "../utils/Context.sol";
import "../utils/Ownable.sol";



contract VAMP is Context, IERC20, IERC20Metadata, Ownable {

    using SafeMath for uint256;

    // Events
    event DevWalletChanged(address indexed previousDevWallet, address indexed newDevWallet);
    event MarketingWalletChanged(address indexed previousMarketingWallet, address indexed newMarketingWallet);

    // Tax Changed Events
    event JackpotTaxOnTransfersChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event MarketingTaxOnTransfersChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event DevTaxOnTransfersChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event JackpotTaxOnBuysChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event MarketingTaxOnBuysChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event DevTaxOnBuysChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event JackpotTaxOnSellsChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event MarketingTaxOnSellsChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event DevTaxOnSellsChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);

    // Fee Events
    event AddressIncludedOrExcludedInFee(address indexed account, bool isExcluded);

    // Max Wallet Events
    event AddressIncludedOrExcludedInMaxWalletSize(address indexed account, bool isExcluded);
    event MaxWalletSizeChanged(uint256 oldMaxWalletSize, uint256 newMaxWalletSize);

    // SpookySwap Events
    event SpookySwapRouterChanged(address indexed newRouterAddress);
    event SpookySwapPairChanged(address indexed oldPairAddress, address indexed newPairAddress);
    event AddressAllowedOrNotToProvideLiquidity(address indexed account, bool isAllowed);

    // Dollar Peg for FTM Events
    event DollarPegChangedToUsdc(address indexed usdcAddessChangedTo);
    event DollarPegChangedToDai(address indexed daiAddessChangedTo);

    // Trading Events
    event TradingOpened(bool isTradingNowOpen);
    event BoughtVAMP(address indexed buyerAddress, uint256 vampBoughtAmount, uint256 timeOfBuy);
    event SoldVAMP(address indexed sellerAddress, uint256 vampSoldAmount, uint256 timeOfSell);
    
    // Morbin Time Events
    event MorbinTimeEnabled(bool MorbinTimeIsEnabled);
    event MorbinTimeDisabled(bool MorbinTimeIsDisabled);
    event MorbinTimeAmountChanged(uint256 oldMorbinTimeAmount, uint256 newMorbinTimeAmount);
    event MorbinTimeMarketingPercentChanged(uint256 oldMorbinTimeMarketingPercent, uint256 newMorbinTimeMarketingPercent);
    event MorbinTimeDevPercentChanged(uint256 oldMorbinTimeDevPercent, uint256 newMorbinTimeDevPercent);
    event MorbinTimeBuybackPercentChanged(uint256 oldMorbinTimeDevPercent, uint256 newMorbinTimeDevPercent);
    event ItsMorbinTime(uint256 amountOfFtmUsedToBuyBackAndBurn, uint256 totalMorbinTimes,uint256 totalMorbinTimeFtmUsedToBuyBackAndBurn,
                        uint256 jackpotBalanceInFtm, uint256 jackpotBalanceInDollarValue, uint256 timeOfMorbinTime);
    event BuyBackForMorbinTime(uint256 amountOfVampThatWasBurned, uint256 totalMorbinTimeVampAmountBoughtBackAndBurned, uint256 timeOfBuyBack); 
                        
    // Jackpot Events
    event JackpotEnabled(bool JackpotIsEnabled);
    event JackpotDisabled(bool JackpotIsDisabled);
    event JackpotFunded(uint256 ftmAddedToJackPot, uint256 timeOfJackpotFunded);
    event JackpotTimeToOccurAfterLastBuyChanged(uint256 oldTimeForJackpotToOccurAfterLastBuy, uint256 newTimeForJackpotToOccurAfterLastBuy);
    event JackpotMinAmountChanged(uint256 oldJackpotMinAmount, uint256 newJackpotMinAmount);
    event JackpotMarketingPercentChanged(uint256 oldMarketingJackpotPercent, uint256 newMarketingJackpotPercent);
    event JackpotDevPercentChanged(uint256 oldDevJackpotPercent, uint256 newDevJackpotPercent);
    event JackpotBuybackPercentChanged(uint256 oldBuybackJackpotPercent, uint256 newBuybackJackpotPercent);
    event JackpotAwarded(address jackpotWinner, uint256 amountFtmAwardedToWinner, uint256 amountOfFtmUsedToBuyBackAndBurn, uint256 totalJackpotTimes, uint256 totalJackpotFtmAmountAwarded, 
                        uint256 totalJackpotDollaValueAwarded, uint256 totalJackpotFtmAmountBoughtBackAndBurned, uint256 jackpotBalanceInFtm, uint256 jackpotBalanceInDollarValue, uint256 timeOfJackpotAward);
    event BuyBackForJackpot(uint256 amountOfVampThatWasBurned, uint256 totalJackpotVampAmountBoughtBackAndBurned, uint256 timeOfBuyBack); 
    event JackpotTimeExtended(address lastBuyer, uint256 lastBuyTimestamp, uint256 jackpotFundAmountInFtmAmount, uint256 jackpotFundAmountInDollarValue, uint256 newTimeForJackpotToOccur);
    
    // Swap Events
    event SwappedFtmForVamp(uint256 ftmAmount, uint256 vampAmountBurned);       
    event SwappedVampForFtm(uint256 vampAmount, uint256 ftmAmount);




    
    

    // Standard ERC-20 Variables
    string private constant _name = "Vampire";
    string private constant _symbol = "VAMP";
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint8 private constant _decimals = 18;
    uint256 private constant _totalSupply = 10**6 * (10**_decimals);    // 1 Million VAMP


    // SpookySwap Variables
    address public spookySwapRouterAddress = 0xF491e7B69E4244ad4002BC14e878a34207E38c29;  
    IUniswapV2Router02 public spookySwapRouter;
    address public spookySwapPairAddress;
    mapping(address => bool) public isAllowedToProvideLiquidity;


    // Vampire Variables

    // Wallet Variables
    address public marketingWallet = 0x722C0b5dc4eDFBAb2d022C3B5c16d95EE7e7D254;
    address public devWallet = _msgSender();

    // Token Variables
    uint256 public constant usdcDecimals = 6;
    address public constant usdcAddress = 0x04068DA6C83AFCFA0e13ba15A6696662335D5B75;
    address public constant daiAddress = 0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E;
    address public dollarPegAddress = usdcAddress;      // can be changed to daiAddress using the change peg function

    // Max Wallet Variables
    uint256 public maxWalletSize = _totalSupply.mul(5).div(100);    // 5%, 50 Thousand
    mapping(address => bool) public isExcludedFromMaxWalletSize;


    // Morbin Time Variables
    bool public isMorbinTimeEnabled = true;

    // uint256 public morbinTimeAmount = 10**4 * 10**_decimals;   // $10,000          // TODO - set this for release
    uint256 public morbinTimeAmount = 10 * 10**_decimals;       // $10 for testing // TODO - delete this

    uint256 public constant morbinTimeAmountMax = 10**6 * 10**_decimals;   // max is $1,000,000  
    uint256 public constant morbinTimeAmountMin = 10**4 * 10**_decimals;   // min is $10,000  
    // Morbin Time Percent Variables
    uint256 public marketingMorbinTimePercent = 9;
    uint256 public constant marketingMorbinTimePercentMax = 9;
    uint256 public devMorbinTimePercent = 1;
    uint256 public constant devMorbinTimePercentMax = 1;
    uint256 public buybackMorbinTimePercent = 70;
    uint256 public constant buybackMorbinTimePercentMax = 70;
    uint256 public constant buybackMorbinTimePercentMin = 50;
    // Morbin Time Tracker Variables
    uint256 public totalMorbinTimes = 0;
    uint256 public totalMorbinTimeVampAmountBoughtBackAndBurned = 0;
    uint256 public totalMorbinTimeFtmAmountBoughtBackAndBurned = 0;
    uint256 public lastTimeMorbinTimeOccured = 0;
    




    // Jackpot Variables
    bool public isJackpotEnabled = true;

    // uint256 public jackpotMinAmount = 10**3 * 10**_decimals;   // $1,000        // TODO - set this for release
    uint256 public jackpotMinAmount = 10**_decimals;   // $1 for test // TODO - delete this

    uint256 public constant jackpotMinAmountMax = 10**4 * 10**_decimals;   // max is $10,000
    uint256 public constant jackpotMinAmountMin = 10**2 * 10**_decimals;   // min is $100
    // Jackpot Percent Variables
    uint256 public constant winnerJackpotPercent = 50;
    uint256 public marketingJackpotPercent = 9;
    uint256 public constant marketingJackpotPercentMax = 9;
    uint256 public devJackpotPercent = 1;
    uint256 public constant devJackpotPercentMax = 1;
    uint256 public buybackJackpotPercent = 10;
    uint256 public constant buybackJackpotPercentMax = 30;
    uint256 public constant buybackJackpotPercentMin = 10;
    // Jackpot Last Buyer Variables
    address public lastBuyer = 0x000000000000000000000000000000000000dEaD;
    uint256 public lastBuyTimestamp = 0;
    uint256 public timeForJackpotToOccurAfterLastBuy = 10 minutes;
    uint256 public constant timeForJackpotToOccurAfterLastBuyMax = 30 minutes;
    uint256 public constant timeForJackpotToOccurAfterLastBuyMin = 5 minutes;


    // Jackpot Min Buy Variables
    // uint256 public minBuyAmountForJackpotLastBuy = 10 * 10**_decimals;   // $10     // TODO  - set this for release
    uint256 public minBuyAmountForJackpotLastBuy = 10**_decimals;   // $1  // TODO - delete this for release  

    uint256 public constant minBuyAmountForJackpotLastBuyMax = 50 * 10**_decimals;   // max is $50
    uint256 public constant minBuyAmountForJackpotLastBuyMin = 10**_decimals;   // min is $1

    bool public isBuyBackForJackpot = true;


    // Jackpot Tracker Variables
    uint256 public totalJackpotTimes = 0;
    uint256 public totalJackpotVampAmountBoughtBackAndBurned = 0;
    uint256 public totalJackpotFtmAmountBoughtBackAndBurned = 0;
    uint256 public totalJackpotAmountAwarded = 0;
    uint256 public lastTimeJackpotOccured = 0;
    uint256 public lastJackpotAmountAwarded = 0;
    address public lastJackpotWinner = 0x000000000000000000000000000000000000dEaD;


    // Morbin Time and Jackpot Variables
    bool public isMorbinOrJackpotin = false;      // Reentrancy Checks
    uint256 public amountToBuybackAndBurnForJackpotOrMorbinTime = 0;
    bool public isTimeToProcessBuyBack = false;
    

    // Tax Variables
    mapping(address => bool) public isExcludedFromFee;
    // Transfer Tax Variables
    uint256 public jackpotTaxOnTransfersPercent = 1;     // 1%
    uint256 public marketingTaxOnTransfersPercent = 1;   // 1%
    uint256 public devTaxOnTransfersPercent = 0;         // 0%
    // Buy Tax Variables
    uint256 public jackpotTaxOnBuysPercent = 2;          // 2%
    uint256 public marketingTaxOnBuysPercent = 1;        // 1%
    uint256 public devTaxOnBuysPercent = 0;              // 0%
    // Sell Tax Variables  
    uint256 public jackpotTaxOnSellsPercent = 5;         // 5%
    uint256 public marketingTaxOnSellsPercent = 2;       // 2%
    uint256 public devTaxOnSellsPercent = 1;             // 1%
    // Tracker Tax Variables
    uint256 public tokensToSellForJackpot = 0;
    uint256 public tokensToSellForMarketing = 0;
    uint256 public tokensToSellForDev = 0;
    // Tax Processing
    bool public isInProcessTaxSwap = false;
    uint256 public minimumVampAmountToSwap = 10**2 * (10**_decimals);    // 100 VAMP
 

    // Misc Variables
    bool public isTradingOpen = false;      // can only set this to true, cannot turn it back to false

    
    


    
    











    // Constructor Logic

    constructor() {
        _balances[owner()] = _totalSupply;

        spookySwapRouter = IUniswapV2Router02(spookySwapRouterAddress);     
        spookySwapPairAddress = IUniswapV2Factory(spookySwapRouter.factory()).createPair(address(this),spookySwapRouter.WETH());

        // Exclude system addresses from fee
        isExcludedFromFee[owner()] = true;
        isExcludedFromFee[address(this)] = true;
        isExcludedFromFee[marketingWallet] = true;
        isExcludedFromFee[0x000000000000000000000000000000000000dEaD] = true;

        isExcludedFromMaxWalletSize[owner()] = true;
        isExcludedFromMaxWalletSize[address(this)] = true;
        isExcludedFromMaxWalletSize[marketingWallet] = true;
        isExcludedFromMaxWalletSize[0x000000000000000000000000000000000000dEaD] = true;
        isExcludedFromMaxWalletSize[spookySwapRouterAddress] = true;
        isExcludedFromMaxWalletSize[spookySwapPairAddress] = true;

        isAllowedToProvideLiquidity[owner()] = true;



        // TODO - remove the extra addresses as you don't need that for live
        isAllowedToProvideLiquidity[marketingWallet] = true;
        isAllowedToProvideLiquidity[0x6913f60A53F5408Df3175B306dd943E83B3a284E] = true;
        isAllowedToProvideLiquidity[0xD4f104D3A3ca2BA42d74B3dcF8FcD6093F460fD5] = true;
        isAllowedToProvideLiquidity[0xB906fc87849E5e66267Af6d3cb1F628E2D637ACC] = true;
        isAllowedToProvideLiquidity[0x37D034f3Bf300aA8a57B162721D8484D63f9a43A] = true;
        isAllowedToProvideLiquidity[0x71E44f71c7D818873dFbBAaaED4dBeb332114Dc0] = true;


        emit Transfer(address(0), owner(), _totalSupply);
    }

    receive() external payable {}








    // Standard ERC-20 Functionality

    function name() external view virtual override returns (string memory) {
        return _name;
    }


    function symbol() external view virtual override returns (string memory) {
        return _symbol;
    }


    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }


    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }


    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }


    function transfer(address receiver, uint256 amount) public virtual override returns (bool) {
        address sender = _msgSender();
        _transfer(sender, receiver, amount);          
        return true;
    }


    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }


    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }


    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }


    function transferFrom(address sender, address receiver, uint256 amount) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(sender, spender, amount);
        _transfer(sender, receiver, amount);
        return true;
    }


    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }


    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }


    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }









    // Vampire Specific Functionality

    // Vampire Views / Getters

    function totalTransferTax() public view returns (uint256) {
        uint256 totalTax = jackpotTaxOnTransfersPercent.add(marketingTaxOnTransfersPercent).add(devTaxOnTransfersPercent);
        return totalTax;
    }


    function totalBuyTax() public view returns (uint256) {
        uint256 totalTax = jackpotTaxOnBuysPercent.add(marketingTaxOnBuysPercent).add(devTaxOnBuysPercent);
        return totalTax;
    }


    function totalSellTax() public view returns (uint256) {
        uint256 totalTax = jackpotTaxOnSellsPercent.add(marketingTaxOnSellsPercent).add(devTaxOnSellsPercent);
        return totalTax;
    }



    // Vampire Setters

    function excludeFromFee(address account, bool isExcluded) external onlyOwner {
        isExcludedFromFee[account] = isExcluded;
        emit AddressIncludedOrExcludedInFee(account, isExcluded);
    }


    function allowAddressToProvideLiquidity(address account, bool isAllowed) external onlyOwner {
        isAllowedToProvideLiquidity[account] = isAllowed;
        emit AddressAllowedOrNotToProvideLiquidity(account, isAllowed);
    }


    function excludeFromMaxWalletSize(address account, bool isExcluded) external onlyOwner {
        isExcludedFromMaxWalletSize[account] = isExcluded;
        if(isExcluded){
            emit AddressIncludedOrExcludedInMaxWalletSize(account, isExcluded);
        }
        else{
            require(account != spookySwapPairAddress, "Cannot be the Pair Address");
            require(account != spookySwapRouterAddress, "Cannot be the Router Address");
            require(account != 0x000000000000000000000000000000000000dEaD, "Cannot be the Dead Address");
            emit AddressIncludedOrExcludedInMaxWalletSize(account, isExcluded);
        }
        
    }


    function setMaxWalletSize(uint256 newWalletSize) external onlyOwner {
        require(newWalletSize >= _totalSupply.div(100),"Max wallet size must be at least 1% of the total supply");       // 1%, 10 Thousand
        emit MaxWalletSizeChanged(maxWalletSize, newWalletSize);
        maxWalletSize = newWalletSize;
    }

    
    function setSpookySwapRouter(address newRouterAddress) external onlyOwner {
        require(newRouterAddress != address(0), "You must supply a non-zero address");
        emit SpookySwapRouterChanged(newRouterAddress);
        spookySwapRouterAddress = newRouterAddress;
        spookySwapRouter = IUniswapV2Router02(newRouterAddress);
    }


    function setSpookySwapPair(address newPairAddress) external onlyOwner {
        require(newPairAddress != address(0), "You must supply a non-zero address");
        emit SpookySwapPairChanged(spookySwapPairAddress, newPairAddress);
        spookySwapPairAddress = newPairAddress;
    }


    function setDevWalletAddress(address newDevWallet) external onlyOwner {
        emit DevWalletChanged(devWallet, newDevWallet);
        devWallet = newDevWallet;
    }


    function setMarketingWalletAddress(address newMarketingWallet) external onlyOwner {
        emit MarketingWalletChanged(marketingWallet, newMarketingWallet);
        marketingWallet = newMarketingWallet;
    }


    function openTrading() external onlyOwner {
        emit TradingOpened(isTradingOpen);
        isTradingOpen = true;     // trading can only be enabled, never disabled
    }


    function setDollarPegToUsdc() external onlyOwner {
        emit DollarPegChangedToUsdc(usdcAddress);
        dollarPegAddress = usdcAddress;
    }


    function setDollarPegToDai() external onlyOwner {
        emit DollarPegChangedToDai(daiAddress);
        dollarPegAddress = daiAddress;
    }


    function setMinVampAmountToSwap(uint256 newAmount) external onlyOwner {
        minimumVampAmountToSwap = newAmount;
    }


    // Tax Setters
    function setJackpotTaxOnTransfers(uint256 newTaxAmount) external onlyOwner {
        emit JackpotTaxOnTransfersChanged(jackpotTaxOnTransfersPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnTransfersPercent).add(marketingTaxOnTransfersPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        jackpotTaxOnTransfersPercent = newTaxAmount;
    }


    function setMarketingTaxOnTransfers(uint256 newTaxAmount) external onlyOwner {
        emit MarketingTaxOnTransfersChanged(marketingTaxOnTransfersPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnTransfersPercent).add(jackpotTaxOnTransfersPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        marketingTaxOnTransfersPercent = newTaxAmount;
    }


    function setDevTaxOnTransfers(uint256 newTaxAmount) external onlyOwner {
        emit DevTaxOnTransfersChanged(devTaxOnTransfersPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(jackpotTaxOnTransfersPercent).add(marketingTaxOnTransfersPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        devTaxOnTransfersPercent = newTaxAmount;
    }


    function setJackpotTaxOnBuys(uint256 newTaxAmount) external onlyOwner {
        emit JackpotTaxOnBuysChanged(jackpotTaxOnBuysPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnBuysPercent).add(marketingTaxOnBuysPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        jackpotTaxOnBuysPercent = newTaxAmount;
    }


    function setMarketingTaxOnBuys(uint256 newTaxAmount) external onlyOwner {
        emit MarketingTaxOnBuysChanged(marketingTaxOnBuysPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnBuysPercent).add(jackpotTaxOnBuysPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        marketingTaxOnBuysPercent = newTaxAmount;
    }


    function setDevTaxOnBuys(uint256 newTaxAmount) external onlyOwner {
        emit DevTaxOnBuysChanged(devTaxOnBuysPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(marketingTaxOnBuysPercent).add(jackpotTaxOnBuysPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        devTaxOnBuysPercent = newTaxAmount;
    }


    function setJackpotTaxOnSells(uint256 newTaxAmount) external onlyOwner {
        emit JackpotTaxOnSellsChanged(jackpotTaxOnSellsPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(marketingTaxOnSellsPercent).add(devTaxOnSellsPercent);
        require(totalTax <= 10, "Tax Amount must be less than the taxLimitSellOnly, which is 10% on sells.");
        jackpotTaxOnSellsPercent = newTaxAmount;
    }


    function setMarketingTaxOnSells(uint256 newTaxAmount) external onlyOwner {
        emit MarketingTaxOnSellsChanged(marketingTaxOnSellsPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnSellsPercent).add(jackpotTaxOnSellsPercent);
        require(totalTax <= 10, "Tax Amount must be less than the taxLimitSellOnly, which is 10% on sells.");
        marketingTaxOnSellsPercent = newTaxAmount;
    }


    function setDevTaxOnSells(uint256 newTaxAmount) external onlyOwner {
        emit DevTaxOnSellsChanged(devTaxOnSellsPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(marketingTaxOnSellsPercent).add(jackpotTaxOnSellsPercent);
        require(totalTax <= 10, "Tax Amount must be less than the taxLimitSellOnly, which is 10% on sells.");
        devTaxOnSellsPercent = newTaxAmount;
    }


    function setMorbinTimeAmount(uint256 newMorbinTimeAmount) external onlyOwner {
        require(newMorbinTimeAmount <= morbinTimeAmountMax, "Must be less than morbinTimeAmountMax");
        require(newMorbinTimeAmount >= morbinTimeAmountMin, "Must be greater than morbinTimeAmountMin");
        emit MorbinTimeAmountChanged(morbinTimeAmount, newMorbinTimeAmount);
        morbinTimeAmount = newMorbinTimeAmount;
    }




    function setMorbinTimeMarketingAndDevPercent(uint256 newMarketingMorbinTimePercent, uint256 newDevMorbinTimePercent) external onlyOwner {
        require(newMarketingMorbinTimePercent <= marketingMorbinTimePercentMax, "Must be less than marketingMorbinTimePercentMax");
        emit MorbinTimeMarketingPercentChanged(marketingMorbinTimePercent, newMarketingMorbinTimePercent);
        marketingMorbinTimePercent = newMarketingMorbinTimePercent;

        require(newDevMorbinTimePercent <= devMorbinTimePercentMax, "Must be less than devMorbinTimePercentMax");
        emit MorbinTimeDevPercentChanged(devMorbinTimePercent, newDevMorbinTimePercent);
        devMorbinTimePercent = newDevMorbinTimePercent;
    }




    function setMorbinTimeBuybackPercent(uint256 newBuybackMorbinTimePercent) external onlyOwner {
        require(newBuybackMorbinTimePercent <= buybackMorbinTimePercentMax, "Must be less than buybackMorbinTimePercentMax");
        require(newBuybackMorbinTimePercent >= buybackMorbinTimePercentMin, "Must be greater than buybackMorbinTimePercentMin");
        emit MorbinTimeBuybackPercentChanged(buybackMorbinTimePercent, newBuybackMorbinTimePercent);
        buybackMorbinTimePercent = newBuybackMorbinTimePercent;
    }


    function setJackpotMinAmount(uint256 newJackpotMinAmount) external onlyOwner {
        require(newJackpotMinAmount <= jackpotMinAmountMax, "Must be less than jackpotMinAmountMax");
        require(newJackpotMinAmount >= jackpotMinAmountMin, "Must be greater than jackpotMinAmountMin");
        emit JackpotMinAmountChanged(jackpotMinAmount, newJackpotMinAmount);
        jackpotMinAmount = newJackpotMinAmount;
    }


    function setJackpotMarketingAndDevPercent(uint256 newMarketingJackpotPercent, uint256 newDevJackpotPercent) external onlyOwner {
        require(newMarketingJackpotPercent <= marketingJackpotPercentMax, "Must be less than marketingJackpotPercentMax");
        emit JackpotMarketingPercentChanged(marketingJackpotPercent, newMarketingJackpotPercent);
        marketingJackpotPercent = newMarketingJackpotPercent;

        require(newDevJackpotPercent <= devJackpotPercentMax, "Must be less than devJackpotPercentMax");
        emit JackpotDevPercentChanged(devJackpotPercent, newDevJackpotPercent);
        devJackpotPercent = newDevJackpotPercent;
    }


    function setJackpotBuybackPercent(uint256 newBuybackJackpotPercent) external onlyOwner {
        require(newBuybackJackpotPercent <= buybackJackpotPercentMax, "Must be less than buybackJackpotPercentMax");
        require(newBuybackJackpotPercent >= buybackJackpotPercentMin, "Must be greater than buybackJackpotPercentMin");
        emit JackpotBuybackPercentChanged(buybackJackpotPercent, newBuybackJackpotPercent);
        buybackJackpotPercent = newBuybackJackpotPercent;
    }


    function setJackpotTimeToOccurAfterLastBuy(uint256 newTimeForJackpotToOccurAfterLastBuy) external onlyOwner {
        require(newTimeForJackpotToOccurAfterLastBuy <= timeForJackpotToOccurAfterLastBuyMax, "Must be less than timeForJackpotToOccurAfterLastBuyMax");
        require(newTimeForJackpotToOccurAfterLastBuy >= timeForJackpotToOccurAfterLastBuyMin, "Must be greater than timeForJackpotToOccurAfterLastBuyMin");
        emit JackpotTimeToOccurAfterLastBuyChanged(timeForJackpotToOccurAfterLastBuy, newTimeForJackpotToOccurAfterLastBuy);
        timeForJackpotToOccurAfterLastBuy = newTimeForJackpotToOccurAfterLastBuy;
    }


    function setJackpotMinBuyForLastBuy(uint256 newMinBuyAmountForJackpotLastBuy) external onlyOwner {
        require(newMinBuyAmountForJackpotLastBuy <= minBuyAmountForJackpotLastBuyMax, "Must be less than minBuyAmountForJackpotLastBuyMax");
        require(newMinBuyAmountForJackpotLastBuy >= minBuyAmountForJackpotLastBuyMin, "Must be greater than minBuyAmountForJackpotLastBuyMin");
        emit JackpotTimeToOccurAfterLastBuyChanged(timeForJackpotToOccurAfterLastBuy, newMinBuyAmountForJackpotLastBuy);
        minBuyAmountForJackpotLastBuy = newMinBuyAmountForJackpotLastBuy;
    }


    function enableOrDisableMorbinTimeOrJackpot(bool enableMorbinTime, bool enableJackpot) external onlyOwner {
        if(enableMorbinTime){
            emit MorbinTimeEnabled(true);
            isMorbinTimeEnabled = true;
        }
        else {
            emit MorbinTimeDisabled(false);
            isMorbinTimeEnabled = false;
        }

        if(enableJackpot){
            emit JackpotEnabled(true);
            isJackpotEnabled = true;
        }
        else {
            emit JackpotDisabled(false);
            isJackpotEnabled = false;
        }
    }










    // Vampire Functions

    // Path Functions for Router

    function getPathFromFtmToDollarPeg() public view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = spookySwapRouter.WETH();
        path[1] = dollarPegAddress;
        return path;
    }


    function getPathFromFtmToVamp() public view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = spookySwapRouter.WETH();
        path[1] = address(this);
        return path;
    }


    function getPathFromVampToFtm() public view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = spookySwapRouter.WETH();
        return path;
    }



    // Price Functions

    function normalizeUsdcDecimals(uint256 amountsOut) public view returns (uint256){        
        if(dollarPegAddress == usdcAddress){
            amountsOut = amountsOut.mul(10**_decimals).div(10**usdcDecimals);
        }
        return amountsOut;
    }



    // VAMP Prices

    function getPriceOfOneVampInDollarValue() public view returns (uint256)  {
        uint256 amountOfFtmForOneVamp = spookySwapRouter.getAmountsOut((10**_decimals), getPathFromVampToFtm())[1];
        uint256 amountOfDollarForFtm = spookySwapRouter.getAmountsOut(amountOfFtmForOneVamp, getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtm);
    }

    function getPriceOfAmountVampWithDecimalsInDollarValue(uint256 vampAmount) public view returns (uint256)  {    
        uint256 amountOfFtmForVampAmount = spookySwapRouter.getAmountsOut(vampAmount.mul(10**_decimals), getPathFromVampToFtm())[1];
        uint256 amountOfDollarForFtm = spookySwapRouter.getAmountsOut(amountOfFtmForVampAmount, getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtm); 
    }

    function getPriceOfAmountVampInDollarValue(uint256 vampAmount) public view returns (uint256)  {
        uint256 amountOfFtmForVampAmount = spookySwapRouter.getAmountsOut(vampAmount, getPathFromVampToFtm())[1];
        uint256 amountOfDollarForFtm = spookySwapRouter.getAmountsOut(amountOfFtmForVampAmount, getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtm);  
    }


    // FTM Prices

    function getPriceOfOneFtmInDollarValue() public view returns (uint256)  {     
        uint256 amountOfDollarForOneFtm = spookySwapRouter.getAmountsOut((10**_decimals), getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForOneFtm);   
    }

    function getPriceOfAmountFtmWithDecimalsInDollarValue(uint256 ftmAmount) public view returns (uint256)  {     
        uint256 amountOfDollarForFtmAmount = spookySwapRouter.getAmountsOut((ftmAmount.mul(10**_decimals)), getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtmAmount);
    }

    function getPriceOfAmountFtmInDollarValue(uint256 ftmAmount) public view returns (uint256)  {
        uint256 amountOfDollarForFtmAmount = spookySwapRouter.getAmountsOut((ftmAmount), getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtmAmount);
    }




    // Jackpot Fund Prices

    function jackpotFundAmountInDollarValue() public view returns (uint256)  {
        uint256 ftmAmountInContract = address(this).balance;
        if(ftmAmountInContract == 0){
            return 0;
        }
        return getPriceOfAmountFtmInDollarValue(ftmAmountInContract);
    }


    // Swap Functions

    function _swapFtmForVamp(uint256 ftmAmount) private {
        emit SwappedFtmForVamp(ftmAmount, spookySwapRouter.getAmountsOut(ftmAmount, getPathFromFtmToVamp())[1]);
        spookySwapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ftmAmount}(0, getPathFromFtmToVamp(), 0x000000000000000000000000000000000000dEaD, block.timestamp.add(2 minutes));
    }


    function _swapVampForFtm(uint256 vampAmount) private {
        emit SwappedVampForFtm(vampAmount, spookySwapRouter.getAmountsOut(vampAmount, getPathFromVampToFtm())[1]);
        spookySwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(vampAmount, 0, getPathFromVampToFtm(), address(this), block.timestamp.add(2 minutes));
    }











    // Process Functions

    function _processBuyBack() private {        // BuyBack From Jackpot and Morbin Time
        
        if(isTimeToProcessBuyBack){

            if(amountToBuybackAndBurnForJackpotOrMorbinTime > 0){

                isTimeToProcessBuyBack = false;

                uint256 vampBalanceOfDeadAddressBeforeBuyBack = balanceOf(0x000000000000000000000000000000000000dEaD);       // balance before BuyBack

                uint256 amountToSwap = amountToBuybackAndBurnForJackpotOrMorbinTime;
                amountToBuybackAndBurnForJackpotOrMorbinTime = 0;   // reentrancy
                _swapFtmForVamp(amountToSwap);

                uint256 vampBalanceOfDeadAddressAfterBuyBack = balanceOf(0x000000000000000000000000000000000000dEaD);    // balance after BuyBack

                uint256 addedVamp = vampBalanceOfDeadAddressAfterBuyBack.sub(vampBalanceOfDeadAddressBeforeBuyBack);    // sub balance after from before
                
                if(isBuyBackForJackpot){
                    totalJackpotVampAmountBoughtBackAndBurned = totalJackpotVampAmountBoughtBackAndBurned.add(addedVamp);   // add to the total
                    emit BuyBackForJackpot(addedVamp, totalJackpotVampAmountBoughtBackAndBurned, block.timestamp);
                }
                else{
                    totalMorbinTimeVampAmountBoughtBackAndBurned = totalMorbinTimeVampAmountBoughtBackAndBurned.add(addedVamp);   // add to the total
                    emit BuyBackForMorbinTime(addedVamp, totalMorbinTimeVampAmountBoughtBackAndBurned, block.timestamp);
                }

                emit JackpotFunded(address(this).balance, block.timestamp);
                
            }
        }
    }








    function _processMorbinTime() private {

        uint256 jackpotFundAmount = jackpotFundAmountInDollarValue();       // check balance of FTM in contract address

        if(jackpotFundAmount >= morbinTimeAmount){      // if higher than $100,000 

            if(!isTimeToProcessBuyBack){

                isMorbinOrJackpotin = true;

                // Morbin Time Percentages
                payable(marketingWallet).transfer(jackpotFundAmount.mul(marketingMorbinTimePercent).div(100));     // 9% marketing
                payable(devWallet).transfer(jackpotFundAmount.mul(devMorbinTimePercent).div(100));     // 1% dev

                uint256 amountToBuybackAndBurn = jackpotFundAmount.mul(buybackMorbinTimePercent).div(100);    // 70%
                amountToBuybackAndBurnForJackpotOrMorbinTime = amountToBuybackAndBurn;      // 70% used to buy back then burn VAMP, 20% left in jackpot  
                isTimeToProcessBuyBack = true;
                isBuyBackForJackpot = false;

                // Tracker Variables
                totalMorbinTimes = totalMorbinTimes.add(1);
                lastTimeMorbinTimeOccured = block.timestamp;
                totalMorbinTimeFtmAmountBoughtBackAndBurned = totalMorbinTimeFtmAmountBoughtBackAndBurned.add(amountToBuybackAndBurn);

                emit ItsMorbinTime(amountToBuybackAndBurn, totalMorbinTimes, totalMorbinTimeFtmAmountBoughtBackAndBurned, address(this).balance, jackpotFundAmountInDollarValue(), block.timestamp);
                
                // reset the last buyer and timestamp 
                lastBuyTimestamp = 0;
                lastBuyer = 0x000000000000000000000000000000000000dEaD;

            }
        }
    }




    










    function _processJackpot() private {

        uint256 jackpotFundAmount = jackpotFundAmountInDollarValue();       // check balance of FTM in contract address

        if(jackpotFundAmount >= jackpotMinAmount){   // if amount is over the minimum required amount, default is $1,000

            if(lastBuyTimestamp != 0){  // only check if timestamp isn't zero, //  if timestamp is zero it means no buy has occured yet

                if(block.timestamp > lastBuyTimestamp.add(timeForJackpotToOccurAfterLastBuy)) { // check time of last buy     // if current time is last buy + time, default 10 minutes after last buy

                    if(lastBuyer != 0x000000000000000000000000000000000000dEaD){    // check last buyer address, as long as it's not a dead address

                        if(!isTimeToProcessBuyBack){

                            isMorbinOrJackpotin = true;

                            // Transfer FTM
                            uint256 amountToAwardLastBuyer = jackpotFundAmount.mul(winnerJackpotPercent).div(100);      // Calculate how much the winner gets
                            payable(lastBuyer).transfer(amountToAwardLastBuyer);    // 50% winner
                            payable(marketingWallet).transfer(jackpotFundAmount.mul(marketingJackpotPercent).div(100));     // 9% marketing
                            payable(devWallet).transfer(jackpotFundAmount.mul(devJackpotPercent).div(100));     // 1% dev

                            uint256 amountToBuybackAndBurn = jackpotFundAmount.mul(buybackJackpotPercent).div(100);    // 10% default
                            amountToBuybackAndBurnForJackpotOrMorbinTime = amountToBuybackAndBurn;       // 10% used to buy back then burn VAMP, 30% left in jackpot 
                            isTimeToProcessBuyBack = true;
                            isBuyBackForJackpot = true;

                            // Tracker Variables
                            lastTimeJackpotOccured = block.timestamp;
                            lastJackpotAmountAwarded = amountToAwardLastBuyer;
                            lastJackpotWinner = lastBuyer;
                            totalJackpotTimes = totalJackpotTimes.add(1);
                            totalJackpotFtmAmountBoughtBackAndBurned = totalJackpotFtmAmountBoughtBackAndBurned.add(amountToBuybackAndBurn);
                            totalJackpotAmountAwarded = totalJackpotAmountAwarded.add(amountToAwardLastBuyer);
                            
                            emit JackpotAwarded(lastBuyer, amountToAwardLastBuyer, amountToBuybackAndBurn, totalJackpotTimes, totalJackpotAmountAwarded, getPriceOfAmountFtmInDollarValue(totalJackpotAmountAwarded),  
                                                totalJackpotFtmAmountBoughtBackAndBurned, address(this).balance, jackpotFundAmountInDollarValue(), block.timestamp);
                            
                            // reset the last buyer and timestamp 
                            lastBuyTimestamp = 0;
                            lastBuyer = 0x000000000000000000000000000000000000dEaD;


                        }
                    }
                }                          
            }
        }
    }





    
    



    function _processTaxSwap() private {

        _approve(address(this), spookySwapRouterAddress, balanceOf(address(this)));

        uint256 balanceOfContractBeforeSwap = address(this).balance;

        _swapVampForFtm(balanceOf(address(this)));      // swaps all the tokens in the contract, which will sell it for FTM

        uint256 balanceOfContractAfterSwap = address(this).balance;

        uint256 balanceToDisperse = balanceOfContractAfterSwap.sub(balanceOfContractBeforeSwap);

        uint256 tokensForJackpotToDisperse = tokensToSellForJackpot;
        tokensToSellForJackpot = 0;
        uint256 tokensForMarketingToDisperse = tokensToSellForMarketing;
        tokensToSellForMarketing = 0;
        uint256 tokensForDevToDisperse = tokensToSellForDev;
        tokensToSellForDev = 0;

        // Calculations for Percentages
        uint256 totalAmountOfTokens = tokensForJackpotToDisperse.add(tokensForMarketingToDisperse).add(tokensForDevToDisperse);
        uint256 percentOfMarketingFtm = tokensForMarketingToDisperse.mul(100).div(totalAmountOfTokens);
        uint256 percentOfDevFtm = tokensForDevToDisperse.mul(100).div(totalAmountOfTokens);

        // Calculate how much FTM to transfer
        uint256 ftmAmountInContractToDisperse = balanceToDisperse;
        uint256 marketingFtm = ftmAmountInContractToDisperse.mul(percentOfMarketingFtm).div(100);
        uint256 devFtm = ftmAmountInContractToDisperse.mul(percentOfDevFtm).div(100);

        // Transfer FTM
        payable(marketingWallet).transfer(marketingFtm);    
        payable(devWallet).transfer(devFtm);

    }















    function _processTaxes(address sender, uint256 amount, uint256 totalTaxPercent, uint256 jackPotTaxPercent, uint256 marketingTaxPercent, uint256 devTaxPercent) private {
        
        uint256 totalTaxAmount = amount.mul(totalTaxPercent).div(100);

        if(totalTaxAmount > 0){    

            uint256 jackpotTaxAmount = amount.mul(jackPotTaxPercent).div(100);
            uint256 marketingWalletTaxAmount = amount.mul(marketingTaxPercent).div(100);
            uint256 devWalletTaxAmount = amount.mul(devTaxPercent).div(100);
            
            _balances[address(this)] += totalTaxAmount;        // transfer in taxes to VAMP Contract for sell
            emit Transfer(sender, address(this), totalTaxAmount);

            tokensToSellForJackpot += jackpotTaxAmount;
            tokensToSellForMarketing += marketingWalletTaxAmount;
            tokensToSellForDev += devWalletTaxAmount;
        }
    }






















    function _processBuy(address sender, address receiver, uint256 amount, uint256 senderBalance, bool takeFee) private {

        if(isJackpotEnabled && !isMorbinOrJackpotin){      // make sure we aren't handling other functions first

            uint256 amountFtmFromVamp = spookySwapRouter.getAmountsOut(amount, getPathFromVampToFtm())[1];      // go from VAMP to FTM
            uint256 priceOfVampBoughtInDollarValue = getPriceOfAmountFtmInDollarValue(amountFtmFromVamp);      // FTM dollar value

            if(priceOfVampBoughtInDollarValue >= minBuyAmountForJackpotLastBuy){           // check dollar value of buy, if more than $10
                if(!isContractByHash(receiver) && !isContractBySize(receiver)){
                    lastBuyTimestamp = block.timestamp;
                    lastBuyer = payable(receiver);
                    uint256 timeForJackpotToOccur = lastBuyTimestamp.add(timeForJackpotToOccurAfterLastBuy);
                    emit JackpotTimeExtended(lastBuyer, lastBuyTimestamp, address(this).balance, jackpotFundAmountInDollarValue(), timeForJackpotToOccur);
                }
            }
        }

        // Transfer Specific
        _balances[sender] = senderBalance.sub(amount);     // transfer out
        uint256 receiverAmount = amount;
        if(takeFee){
            receiverAmount = amount.sub(amount.mul(totalBuyTax()).div(100));
        }
        _balances[receiver] += receiverAmount;       // transfer in
        emit Transfer(sender, receiver, receiverAmount);
        emit BoughtVAMP(receiver, receiverAmount, block.timestamp);

    }













    function _processSell(address sender, address receiver, uint256 amount, uint256 senderBalance, bool takeFee) private {
        
        // Transfer Specific
        _balances[sender] = senderBalance.sub(amount);     // transfer out
        uint256 receiverAmount = amount;
        if(takeFee){
            receiverAmount = amount.sub(amount.mul(totalSellTax()).div(100));
        }
        _balances[receiver] += receiverAmount;       // transfer in
        emit Transfer(sender, receiver, receiverAmount);
        emit SoldVAMP(sender, receiverAmount, block.timestamp);

    }



















    function _processNormalTransfer(address sender, address receiver, uint256 amount, uint256 senderBalance, bool takeFee) private {

        // Transfer Specific
        _balances[sender] = senderBalance.sub(amount);     // transfer out
        uint256 receiverAmount = amount;
        if(takeFee){
            receiverAmount = amount.sub(amount.mul(totalTransferTax()).div(100));
        }
        _balances[receiver] += receiverAmount;       // transfer in
        emit Transfer(sender, receiver, receiverAmount);

    }


   


    
















    function _transfer(address sender, address receiver, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(receiver != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        // reentrancy
        uint256 senderBalance = _balances[sender];
        _balances[sender] = 0;      // sets the balance to 0 temporarily, at the end it is recalculated correctly. 

        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");


        if(!isExcludedFromMaxWalletSize[receiver]){
            uint256 receiverBalance = _balances[receiver].add(amount);
            require(receiverBalance <= maxWalletSize, "Must not go over max wallet size.");
        }
  

        if(!isAllowedToProvideLiquidity[sender] && !isAllowedToProvideLiquidity[receiver] ){   
            if(sender == spookySwapPairAddress || receiver == spookySwapPairAddress){      // allows transfers, but not trading
                require(isTradingOpen, "Trading is Not Open");          // isTradingOpen is set to true to open trading, can never be set to false to stop trades
            }
        }



    
        // Morbin Time
        if(isMorbinTimeEnabled && !isMorbinOrJackpotin){
            _processMorbinTime();
        }
        

        // Jackpot
        if(isJackpotEnabled && !isMorbinOrJackpotin){
            _processJackpot();
        }
        

        // Process BuyBack
        if(!(spookySwapPairAddress == sender)){       // if this is not a buy, then we need to process the buyback
            if(!isInProcessTaxSwap){
                isInProcessTaxSwap = true;
                _processBuyBack();
                isInProcessTaxSwap = false;
            }
        }



        // Taxes
        bool takeFee = true;
        if(isExcludedFromFee[sender] || isExcludedFromFee[receiver]){
            takeFee = false;
        }



    
        // Process Taxes
        if(!(spookySwapPairAddress == sender)){       // if this is not a buy, then we need to process the tax tokens
            if(balanceOf(address(this)) >= minimumVampAmountToSwap){        // the minimum is 100 VAMP
                if(!isInProcessTaxSwap){
                    isInProcessTaxSwap = true;
                    _processTaxSwap();
                    isInProcessTaxSwap = false;
                }
            }
        }


        // Tax Collection
        uint256 totalTaxPercent = 0;
        uint256 jackPotTaxPercent = 0;
        uint256 marketingTaxPercent = 0;
        uint256 devTaxPercent = 0;
   

        if(spookySwapPairAddress != receiver && spookySwapPairAddress != sender){     // Normal Transfer
            _processNormalTransfer(sender, receiver, amount, senderBalance, takeFee);
            totalTaxPercent = totalTransferTax();
            jackPotTaxPercent = jackpotTaxOnTransfersPercent;
            marketingTaxPercent = marketingTaxOnTransfersPercent;
            devTaxPercent = devTaxOnTransfersPercent;
        }


        if(spookySwapPairAddress == sender){       // Buy
            _processBuy(sender, receiver, amount, senderBalance, takeFee);
            totalTaxPercent = totalBuyTax();
            jackPotTaxPercent = jackpotTaxOnBuysPercent;
            marketingTaxPercent = marketingTaxOnBuysPercent;
            devTaxPercent = devTaxOnBuysPercent;
        }


        if(spookySwapPairAddress == receiver){     // Sell
            _processSell(sender, receiver, amount, senderBalance, takeFee);
            totalTaxPercent = totalSellTax();
            jackPotTaxPercent = jackpotTaxOnSellsPercent;
            marketingTaxPercent = marketingTaxOnSellsPercent;
            devTaxPercent = devTaxOnSellsPercent;
        }



        // Take The Taxes
        if(takeFee){
            _processTaxes(sender, amount, totalTaxPercent, jackPotTaxPercent, marketingTaxPercent, devTaxPercent);
        }


        isMorbinOrJackpotin = false;

    }



    function isContractByHash(address account) public view returns (bool) {   
        bytes32 hash;
        assembly {hash := extcodehash(account)}
        return ((hash != 0x0) && (hash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470));
    }


    function isContractBySize(address account) public view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return (size > 0);
    }









    // TODO - remove save functions, this is for testing purposes only
    function GetAllFtmInContract() external onlyOwner  {   
        payable(_msgSender()).transfer(address(this).balance);
    }



    // TODO  - test on the live net to see if someone can do an exploit with adding the liquidity


}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.15;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.15;

import "./IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.15;

import './IUniswapV2Router01.sol';

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.15;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.15;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.15;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.15;

import "./Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.15;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}